#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:dynamic,enum
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID
from enum import IntEnum

import sys
import shared.ttypes

from thrift.transport import TTransport
from thrift.protocol.TBase import TBase, TFrozenBase, TExceptionBase, TFrozenExceptionBase, TTransport
all_structs = []


class Operation(IntEnum):
    """
    You can define enums, which are just 32 bit integers. Values are optional
    and start at 1 if not supplied, C style again.

    """
    ADD = 1
    SUBTRACT = 2
    MULTIPLY = 3
    DIVIDE = 4



class Work(TBase):
    """
    Structs are the basic complex data structures. They are comprised of fields
    which each have an integer identifier, a type, a symbolic name, and an
    optional default value.

    Fields can be declared "optional", which ensures they will not be included
    in the serialized output if they aren't set.  Note that this requires some
    manual management in some languages.

    Attributes:
     - num1
     - num2
     - op
     - comment

    """
    thrift_spec = None


    def __init__(self, num1 = 0, num2 = None, op = None, comment = None,):
        self.num1 = num1
        self.num2 = num2
        self.op = op
        self.comment = comment

    def __setattr__(self, name, value):
        if name == "op":
            super().__setattr__(name, value if hasattr(value, 'value') else Operation.__members__.get(value))
            return
        super().__setattr__(name, value)


    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidOperation(TFrozenExceptionBase):
    """
    Structs can also be exceptions, if they are nasty.

    Attributes:
     - whatOp
     - why

    """
    thrift_spec = None


    def __init__(self, whatOp = None, why = None,):
        super(InvalidOperation, self).__setattr__('whatOp', whatOp)
        super(InvalidOperation, self).__setattr__('why', why)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.whatOp, self.why, ))

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Work)
Work.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num1', None, 0, ),  # 1
    (2, TType.I32, 'num2', None, None, ),  # 2
    (3, TType.I32, 'op', None, None, ),  # 3
    (4, TType.STRING, 'comment', 'UTF8', None, ),  # 4
)
all_structs.append(InvalidOperation)
InvalidOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'whatOp', None, None, ),  # 1
    (2, TType.STRING, 'why', 'UTF8', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
